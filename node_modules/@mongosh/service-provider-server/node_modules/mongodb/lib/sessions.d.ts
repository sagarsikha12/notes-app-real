import { Binary, Timestamp, Document } from './bson';
import { TxnState, Transaction, TransactionOptions } from './transactions';
import { ClusterTime } from './sdam/common';
import { MongoDriverError } from './error';
import { Callback } from './utils';
import type { Topology } from './sdam/topology';
import type { MongoOptions } from './mongo_client';
import type { AbstractCursor } from './cursor/abstract_cursor';
import type { CommandOptions, Connection } from './cmap/connection';
import { TypedEventEmitter } from './mongo_types';
/** @public */
export interface ClientSessionOptions {
    /** Whether causal consistency should be enabled on this session */
    causalConsistency?: boolean;
    /** The default TransactionOptions to use for transactions started on this session. */
    defaultTransactionOptions?: TransactionOptions;
    /** @internal */
    owner?: symbol | AbstractCursor;
    /** @internal */
    explicit?: boolean;
    /** @internal */
    initialClusterTime?: ClusterTime;
    /** @internal */
    loadBalanced: boolean;
}
/** @public */
export declare type WithTransactionCallback<T = void> = (session: ClientSession) => Promise<T>;
/** @public */
export declare type ClientSessionEvents = {
    ended(session: ClientSession): void;
};
/** @internal */
declare const kServerSession: unique symbol;
/** @internal */
declare const kPinnedConnection: unique symbol;
/**
 * A class representing a client session on the server
 *
 * NOTE: not meant to be instantiated directly.
 * @public
 */
declare class ClientSession extends TypedEventEmitter<ClientSessionEvents> {
    /** @internal */
    topology: Topology;
    /** @internal */
    sessionPool: ServerSessionPool;
    hasEnded: boolean;
    clientOptions?: MongoOptions;
    supports: {
        causalConsistency: boolean;
    };
    clusterTime?: ClusterTime;
    operationTime?: Timestamp;
    explicit: boolean;
    /** @internal */
    owner?: symbol | AbstractCursor;
    defaultTransactionOptions: TransactionOptions;
    transaction: Transaction;
    loadBalanced: boolean;
    /** @internal */
    [kServerSession]?: ServerSession;
    /** @internal */
    [kPinnedConnection]?: Connection;
    /**
     * Create a client session.
     * @internal
     * @param topology - The current client's topology (Internal Class)
     * @param sessionPool - The server session pool (Internal Class)
     * @param options - Optional settings
     * @param clientOptions - Optional settings provided when creating a MongoClient
     */
    constructor(topology: Topology, sessionPool: ServerSessionPool, options: ClientSessionOptions, clientOptions?: MongoOptions);
    /** The server id associated with this session */
    get id(): ServerSessionId | undefined;
    get serverSession(): ServerSession;
    /** @internal */
    get pinnedConnection(): Connection | undefined;
    /** @internal */
    pinConnection(conn: Connection): void;
    /** @internal */
    unpinConnection(): void;
    /**
     * Ends this session on the server
     *
     * @param options - Optional settings. Currently reserved for future use
     * @param callback - Optional callback for completion of this operation
     */
    endSession(): Promise<void>;
    endSession(callback: Callback<void>): void;
    endSession(options: Record<string, unknown>): Promise<void>;
    endSession(options: Record<string, unknown>, callback: Callback<void>): void;
    /**
     * Advances the operationTime for a ClientSession.
     *
     * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to
     */
    advanceOperationTime(operationTime: Timestamp): void;
    /**
     * Used to determine if this session equals another
     *
     * @param session - The session to compare to
     */
    equals(session: ClientSession): boolean;
    /** Increment the transaction number on the internal ServerSession */
    incrementTransactionNumber(): void;
    /** @returns whether this session is currently in a transaction or not */
    inTransaction(): boolean;
    /**
     * Starts a new transaction with the given options.
     *
     * @param options - Options for the transaction
     */
    startTransaction(options?: TransactionOptions): void;
    /**
     * Commits the currently active transaction in this session.
     *
     * @param callback - An optional callback, a Promise will be returned if none is provided
     */
    commitTransaction(): Promise<Document>;
    commitTransaction(callback: Callback<Document>): void;
    /**
     * Aborts the currently active transaction in this session.
     *
     * @param callback - An optional callback, a Promise will be returned if none is provided
     */
    abortTransaction(): Promise<Document>;
    abortTransaction(callback: Callback<Document>): void;
    /**
     * This is here to ensure that ClientSession is never serialized to BSON.
     */
    toBSON(): never;
    /**
     * Runs a provided lambda within a transaction, retrying either the commit operation
     * or entire transaction as needed (and when the error permits) to better ensure that
     * the transaction can complete successfully.
     *
     * IMPORTANT: This method requires the user to return a Promise, all lambdas that do not
     * return a Promise will result in undefined behavior.
     *
     * @param fn - A lambda to run within a transaction
     * @param options - Optional settings for the transaction
     */
    withTransaction<T = void>(fn: WithTransactionCallback<T>, options?: TransactionOptions): ReturnType<typeof fn>;
}
/** @public */
export declare type ServerSessionId = {
    id: Binary;
};
/**
 * Reflects the existence of a session on the server. Can be reused by the session pool.
 * WARNING: not meant to be instantiated directly. For internal use only.
 * @public
 */
declare class ServerSession {
    id: ServerSessionId;
    lastUse: number;
    txnNumber: number;
    isDirty: boolean;
    /** @internal */
    constructor();
    /**
     * Determines if the server session has timed out.
     *
     * @param sessionTimeoutMinutes - The server's "logicalSessionTimeoutMinutes"
     */
    hasTimedOut(sessionTimeoutMinutes: number): boolean;
}
/**
 * Maintains a pool of Server Sessions.
 * For internal use only
 * @internal
 */
declare class ServerSessionPool {
    topology: Topology;
    sessions: ServerSession[];
    constructor(topology: Topology);
    /** Ends all sessions in the session pool */
    endAllPooledSessions(callback?: Callback<void>): void;
    /**
     * Acquire a Server Session from the pool.
     * Iterates through each session in the pool, removing any stale sessions
     * along the way. The first non-stale session found is removed from the
     * pool and returned. If no non-stale session is found, a new ServerSession is created.
     */
    acquire(): ServerSession;
    /**
     * Release a session to the session pool
     * Adds the session back to the session pool if the session has not timed out yet.
     * This method also removes any stale sessions from the pool.
     *
     * @param session - The session to release to the pool
     */
    release(session: ServerSession): void;
}
declare function commandSupportsReadConcern(command: Document, options?: Document): boolean;
/**
 * Optionally decorate a command with sessions specific keys
 *
 * @param session - the session tracking transaction state
 * @param command - the command to decorate
 * @param options - Optional settings passed to calling operation
 */
declare function applySession(session: ClientSession, command: Document, options?: CommandOptions): MongoDriverError | undefined;
declare function updateSessionFromResponse(session: ClientSession, document: Document): void;
export { ClientSession, ServerSession, ServerSessionPool, TxnState, applySession, updateSessionFromResponse, commandSupportsReadConcern };
//# sourceMappingURL=sessions.d.ts.map