import { MessageStream, OperationDescription } from './message_stream';
import { StreamDescription, StreamDescriptionOptions } from './stream_description';
import { CommandStartedEvent, CommandFailedEvent, CommandSucceededEvent } from './command_monitoring_events';
import { ClientSession } from '../sessions';
import { ClientMetadata, Callback, MongoDBNamespace, HostAddress } from '../utils';
import { BSONSerializeOptions, Document, Long, ObjectId } from '../bson';
import type { AutoEncrypter } from '../deps';
import type { MongoCredentials } from './auth/mongo_credentials';
import type { Stream } from './connect';
import { ReadPreference, ReadPreferenceLike } from '../read_preference';
import type { W, WriteConcern, WriteConcernOptions } from '../write_concern';
import type { ServerApi, SupportedNodeConnectionOptions } from '../mongo_client';
import { CancellationToken, TypedEventEmitter } from '../mongo_types';
/** @internal */
declare const kStream: unique symbol;
/** @internal */
declare const kQueue: unique symbol;
/** @internal */
declare const kMessageStream: unique symbol;
/** @internal */
declare const kGeneration: unique symbol;
/** @internal */
declare const kLastUseTime: unique symbol;
/** @internal */
declare const kClusterTime: unique symbol;
/** @internal */
declare const kDescription: unique symbol;
/** @internal */
declare const kIsMaster: unique symbol;
/** @internal */
declare const kAutoEncrypter: unique symbol;
/** @internal */
export interface QueryOptions extends BSONSerializeOptions {
    readPreference: ReadPreference;
    documentsReturnedIn?: string;
    batchSize?: number;
    limit?: number;
    skip?: number;
    projection?: Document;
    tailable?: boolean;
    awaitData?: boolean;
    noCursorTimeout?: boolean;
    /** @deprecated use `noCursorTimeout` instead */
    timeout?: boolean;
    partial?: boolean;
    oplogReplay?: boolean;
}
/** @public */
export interface CommandOptions extends BSONSerializeOptions {
    command?: boolean;
    slaveOk?: boolean;
    /** Specify read preference if command supports it */
    readPreference?: ReadPreferenceLike;
    raw?: boolean;
    monitoring?: boolean;
    fullResult?: boolean;
    socketTimeoutMS?: number;
    /** Session to use for the operation */
    session?: ClientSession;
    documentsReturnedIn?: string;
    noResponse?: boolean;
    willRetryWrite?: boolean;
    writeConcern?: WriteConcernOptions | WriteConcern | W;
}
/** @internal */
export interface GetMoreOptions extends CommandOptions {
    batchSize?: number;
    maxTimeMS?: number;
    maxAwaitTimeMS?: number;
    comment?: Document | string;
}
/** @public */
export interface ConnectionOptions extends SupportedNodeConnectionOptions, StreamDescriptionOptions {
    id: number | '<monitor>';
    generation: number;
    hostAddress: HostAddress;
    autoEncrypter?: AutoEncrypter;
    serverApi?: ServerApi;
    monitorCommands: boolean;
    /** @internal */
    connectionType?: typeof Connection;
    credentials?: MongoCredentials;
    connectTimeoutMS?: number;
    tls: boolean;
    keepAlive?: boolean;
    keepAliveInitialDelay?: number;
    noDelay?: boolean;
    socketTimeoutMS?: number;
    cancellationToken?: CancellationToken;
    metadata: ClientMetadata;
}
/** @public */
export interface DestroyOptions {
    /** Force the destruction. */
    force?: boolean;
}
/** @public */
export declare type ConnectionEvents = {
    commandStarted(event: CommandStartedEvent): void;
    commandSucceeded(event: CommandSucceededEvent): void;
    commandFailed(event: CommandFailedEvent): void;
    clusterTimeReceived(clusterTime: Document): void;
    close(): void;
    message(message: any): void;
};
/** @internal */
export declare class Connection extends TypedEventEmitter<ConnectionEvents> {
    id: number | '<monitor>';
    address: string;
    socketTimeoutMS: number;
    monitorCommands: boolean;
    closed: boolean;
    destroyed: boolean;
    lastIsMasterMS?: number;
    serverApi?: ServerApi;
    pinType?: string;
    /** @internal */
    [kDescription]: StreamDescription;
    /** @internal */
    [kGeneration]: number;
    /** @internal */
    [kLastUseTime]: number;
    /** @internal */
    [kQueue]: Map<number, OperationDescription>;
    /** @internal */
    [kMessageStream]: MessageStream;
    /** @internal */
    [kStream]: Stream;
    /** @internal */
    [kIsMaster]: Document;
    /** @internal */
    [kClusterTime]: Document;
    /** @event */
    static readonly COMMAND_STARTED: "commandStarted";
    /** @event */
    static readonly COMMAND_SUCCEEDED: "commandSucceeded";
    /** @event */
    static readonly COMMAND_FAILED: "commandFailed";
    /** @event */
    static readonly CLUSTER_TIME_RECEIVED: "clusterTimeReceived";
    /** @event */
    static readonly CLOSE: "close";
    /** @event */
    static readonly MESSAGE: "message";
    constructor(stream: Stream, options: ConnectionOptions);
    get description(): StreamDescription;
    get ismaster(): Document;
    set ismaster(response: Document);
    get serviceId(): ObjectId | undefined;
    get loadBalanced(): boolean;
    get generation(): number;
    set generation(generation: number);
    get idleTime(): number;
    get clusterTime(): Document;
    get stream(): Stream;
    markAvailable(): void;
    /**
     * Mark the connection as pinned if it isn't already pinned. An example
     * of this is if the connection is pinned to a transaction, and we've
     * started a cursor inside the transaction, we want to keep the tracking
     * for the metrics as the transaction.
     */
    markPinned(pinType: string): void;
    /**
     * Mark the connection as unpinned only if the pin type is the same.
     */
    markUnpinned(pinType: string): void;
    handleIssue(issue: {
        isTimeout?: boolean;
        isClose?: boolean;
        destroy?: boolean | Error;
    }): void;
    destroy(): void;
    destroy(callback: Callback): void;
    destroy(options: DestroyOptions): void;
    destroy(options: DestroyOptions, callback: Callback): void;
    /** @internal */
    command(ns: MongoDBNamespace, cmd: Document, options: CommandOptions | undefined, callback: Callback): void;
    /** @internal */
    query(ns: MongoDBNamespace, cmd: Document, options: QueryOptions, callback: Callback): void;
    /** @internal */
    getMore(ns: MongoDBNamespace, cursorId: Long, options: GetMoreOptions, callback: Callback<Document>): void;
    /** @internal */
    killCursors(ns: MongoDBNamespace, cursorIds: Long[], options: CommandOptions, callback: Callback): void;
}
/** @public */
export declare const APM_EVENTS: ("commandStarted" | "commandSucceeded" | "commandFailed")[];
/** @internal */
export declare class CryptoConnection extends Connection {
    /** @internal */
    [kAutoEncrypter]?: AutoEncrypter;
    constructor(stream: Stream, options: ConnectionOptions);
    /** @internal @override */
    command(ns: MongoDBNamespace, cmd: Document, options: CommandOptions, callback: Callback): void;
}
/** @public */
export declare function hasSessionSupport(conn: Connection): boolean;
export {};
//# sourceMappingURL=connection.d.ts.map