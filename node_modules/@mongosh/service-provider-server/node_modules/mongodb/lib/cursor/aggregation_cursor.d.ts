import { AggregateOptions } from '../operations/aggregate';
import { AbstractCursor } from './abstract_cursor';
import { ExecutionResult } from '../operations/execute_operation';
import type { Document } from '../bson';
import type { Sort } from '../sort';
import type { Topology } from '../sdam/topology';
import type { Callback, MongoDBNamespace } from '../utils';
import type { ClientSession } from '../sessions';
import type { OperationParent } from '../operations/command';
import type { AbstractCursorOptions } from './abstract_cursor';
import type { ExplainVerbosityLike } from '../explain';
import type { Projection } from '../mongo_types';
/** @public */
export interface AggregationCursorOptions extends AbstractCursorOptions, AggregateOptions {
}
/** @internal */
declare const kParent: unique symbol;
/** @internal */
declare const kPipeline: unique symbol;
/** @internal */
declare const kOptions: unique symbol;
/**
 * The **AggregationCursor** class is an internal class that embodies an aggregation cursor on MongoDB
 * allowing for iteration over the results returned from the underlying query. It supports
 * one by one document iteration, conversion to an array or can be iterated as a Node 4.X
 * or higher stream
 * @public
 */
export declare class AggregationCursor<TSchema = Document> extends AbstractCursor<TSchema> {
    /** @internal */
    [kParent]: OperationParent;
    /** @internal */
    [kPipeline]: Document[];
    /** @internal */
    [kOptions]: AggregateOptions;
    /** @internal */
    constructor(parent: OperationParent, topology: Topology, namespace: MongoDBNamespace, pipeline?: Document[], options?: AggregateOptions);
    get pipeline(): Document[];
    clone(): AggregationCursor<TSchema>;
    map<T>(transform: (doc: TSchema) => T): AggregationCursor<T>;
    /** @internal */
    _initialize(session: ClientSession | undefined, callback: Callback<ExecutionResult>): void;
    /** Execute the explain for the cursor */
    explain(): Promise<Document>;
    explain(callback: Callback): void;
    explain(verbosity: ExplainVerbosityLike): Promise<Document>;
    /** Add a group stage to the aggregation pipeline */
    group<T = TSchema>($group: Document): AggregationCursor<T>;
    /** Add a limit stage to the aggregation pipeline */
    limit($limit: number): this;
    /** Add a match stage to the aggregation pipeline */
    match($match: Document): this;
    /** Add a out stage to the aggregation pipeline */
    out($out: number): this;
    /**
     * Add a project stage to the aggregation pipeline
     *
     * @remarks
     * In order to strictly type this function you must provide an interface
     * that represents the effect of your projection on the result documents.
     *
     * **NOTE:** adding a projection changes the return type of the iteration of this cursor,
     * it **does not** return a new instance of a cursor. This means when calling project,
     * you should always assign the result to a new variable. Take note of the following example:
     *
     * @example
     * ```typescript
     * const cursor: AggregationCursor<{ a: number; b: string }> = coll.aggregate([]);
     * const projectCursor = cursor.project<{ a: number }>({ a: true });
     * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();
     * ```
     */
    project<T = TSchema>($project: Projection<T>): AggregationCursor<T>;
    /** Add a lookup stage to the aggregation pipeline */
    lookup($lookup: Document): this;
    /** Add a redact stage to the aggregation pipeline */
    redact($redact: Document): this;
    /** Add a skip stage to the aggregation pipeline */
    skip($skip: number): this;
    /** Add a sort stage to the aggregation pipeline */
    sort($sort: Sort): this;
    /** Add a unwind stage to the aggregation pipeline */
    unwind($unwind: Document | string): this;
    /** @deprecated Add a geoNear stage to the aggregation pipeline */
    geoNear($geoNear: Document): this;
}
export {};
//# sourceMappingURL=aggregation_cursor.d.ts.map