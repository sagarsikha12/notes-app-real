/// <reference types="node" />
import { Callback, MongoDBNamespace } from '../utils';
import { Long, Document, BSONSerializeOptions } from '../bson';
import { ClientSession } from '../sessions';
import { ReadPreference, ReadPreferenceLike } from '../read_preference';
import type { Server } from '../sdam/server';
import type { Topology } from '../sdam/topology';
import { Readable } from 'stream';
import type { ExecutionResult } from '../operations/execute_operation';
import { ReadConcern, ReadConcernLike } from '../read_concern';
import { TypedEventEmitter } from '../mongo_types';
/** @internal */
declare const kId: unique symbol;
/** @internal */
declare const kDocuments: unique symbol;
/** @internal */
declare const kServer: unique symbol;
/** @internal */
declare const kNamespace: unique symbol;
/** @internal */
declare const kTopology: unique symbol;
/** @internal */
declare const kSession: unique symbol;
/** @internal */
declare const kOptions: unique symbol;
/** @internal */
declare const kTransform: unique symbol;
/** @internal */
declare const kInitialized: unique symbol;
/** @internal */
declare const kClosed: unique symbol;
/** @internal */
declare const kKilled: unique symbol;
/** @public */
export declare const CURSOR_FLAGS: readonly ["tailable", "oplogReplay", "noCursorTimeout", "awaitData", "exhaust", "partial"];
/** @public */
export interface CursorCloseOptions {
    /** Bypass calling killCursors when closing the cursor. */
    skipKillCursors?: boolean;
}
/** @public */
export interface CursorStreamOptions {
    /** A transformation method applied to each document emitted by the stream */
    transform?(doc: Document): Document;
}
/** @public */
export declare type CursorFlag = typeof CURSOR_FLAGS[number];
/** @public */
export interface AbstractCursorOptions extends BSONSerializeOptions {
    session?: ClientSession;
    readPreference?: ReadPreferenceLike;
    readConcern?: ReadConcernLike;
    batchSize?: number;
    maxTimeMS?: number;
    comment?: Document | string;
    tailable?: boolean;
    awaitData?: boolean;
    noCursorTimeout?: boolean;
}
/** @internal */
export declare type InternalAbstractCursorOptions = Omit<AbstractCursorOptions, 'readPreference'> & {
    readPreference: ReadPreference;
    readConcern?: ReadConcern;
    oplogReplay?: boolean;
    exhaust?: boolean;
    partial?: boolean;
};
/** @public */
export declare type AbstractCursorEvents = {
    [AbstractCursor.CLOSE](): void;
};
/** @public */
export declare abstract class AbstractCursor<TSchema = any, CursorEvents extends AbstractCursorEvents = AbstractCursorEvents> extends TypedEventEmitter<CursorEvents> {
    /** @internal */
    [kId]?: Long;
    /** @internal */
    [kSession]?: ClientSession;
    /** @internal */
    [kServer]?: Server;
    /** @internal */
    [kNamespace]: MongoDBNamespace;
    /** @internal */
    [kDocuments]: TSchema[];
    /** @internal */
    [kTopology]: Topology;
    /** @internal */
    [kTransform]?: (doc: TSchema) => Document;
    /** @internal */
    [kInitialized]: boolean;
    /** @internal */
    [kClosed]: boolean;
    /** @internal */
    [kKilled]: boolean;
    /** @internal */
    [kOptions]: InternalAbstractCursorOptions;
    /** @event */
    static readonly CLOSE: "close";
    /** @internal */
    constructor(topology: Topology, namespace: MongoDBNamespace, options?: AbstractCursorOptions);
    get id(): Long | undefined;
    /** @internal */
    get topology(): Topology;
    /** @internal */
    get server(): Server | undefined;
    get namespace(): MongoDBNamespace;
    get readPreference(): ReadPreference;
    get readConcern(): ReadConcern | undefined;
    /** @internal */
    get session(): ClientSession | undefined;
    set session(clientSession: ClientSession | undefined);
    /** @internal */
    get cursorOptions(): InternalAbstractCursorOptions;
    get closed(): boolean;
    get killed(): boolean;
    get loadBalanced(): boolean;
    /** Returns current buffered documents length */
    bufferedCount(): number;
    /** Returns current buffered documents */
    readBufferedDocuments(number?: number): TSchema[];
    [Symbol.asyncIterator](): AsyncIterator<TSchema | null>;
    stream(options?: CursorStreamOptions): Readable;
    hasNext(): Promise<boolean>;
    hasNext(callback: Callback<boolean>): void;
    /** Get the next available document from the cursor, returns null if no more documents are available. */
    next<T = TSchema>(): Promise<T | null>;
    next<T = TSchema>(callback: Callback<T | null>): void;
    /**
     * Try to get the next available document from the cursor or `null` if an empty batch is returned
     */
    tryNext<T = TSchema>(): Promise<T | null>;
    tryNext<T = TSchema>(callback: Callback<T | null>): void;
    /**
     * Iterates over all the documents for this cursor using the iterator, callback pattern.
     *
     * @param iterator - The iteration callback.
     * @param callback - The end callback.
     */
    forEach<T = TSchema>(iterator: (doc: T) => boolean | void): Promise<void>;
    forEach<T = TSchema>(iterator: (doc: T) => boolean | void, callback: Callback<void>): void;
    close(): void;
    close(callback: Callback): void;
    close(options: CursorCloseOptions): Promise<void>;
    close(options: CursorCloseOptions, callback: Callback): void;
    /**
     * Returns an array of documents. The caller is responsible for making sure that there
     * is enough memory to store the results. Note that the array only contains partial
     * results when this cursor had been previously accessed. In that case,
     * cursor.rewind() can be used to reset the cursor.
     *
     * @param callback - The result callback.
     */
    toArray<T = TSchema>(): Promise<T[]>;
    toArray<T = TSchema>(callback: Callback<T[]>): void;
    /**
     * Add a cursor flag to the cursor
     *
     * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.
     * @param value - The flag boolean value.
     */
    addCursorFlag(flag: CursorFlag, value: boolean): this;
    /**
     * Map all documents using the provided function
     * If there is a transform set on the cursor, that will be called first and the result passed to
     * this function's transform.
     * @remarks
     *
     * **NOTE:** adding a transform changes the return type of the iteration of this cursor, it **does not** return
     * a new instance of a cursor. This means when calling map, you should always assign the result to a new
     * variable. Take note of the following example:
     *
     * @example
     * ```typescript
     * const cursor: FindCursor<Document> = coll.find();
     * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);
     * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]
     * ```
     * @param transform - The mapping transformation method.
     */
    map<T = any>(transform: (doc: TSchema) => T): AbstractCursor<T>;
    /**
     * Set the ReadPreference for the cursor.
     *
     * @param readPreference - The new read preference for the cursor.
     */
    withReadPreference(readPreference: ReadPreferenceLike): this;
    /**
     * Set the ReadPreference for the cursor.
     *
     * @param readPreference - The new read preference for the cursor.
     */
    withReadConcern(readConcern: ReadConcernLike): this;
    /**
     * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)
     *
     * @param value - Number of milliseconds to wait before aborting the query.
     */
    maxTimeMS(value: number): this;
    /**
     * Set the batch size for the cursor.
     *
     * @param value - The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/|find command documentation}.
     */
    batchSize(value: number): this;
    /**
     * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will
     * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even
     * if the resultant data has already been retrieved by this cursor.
     */
    rewind(): void;
    /**
     * Returns a new uninitialized copy of this cursor, with options matching those that have been set on the current instance
     */
    abstract clone(): AbstractCursor<TSchema>;
    /** @internal */
    abstract _initialize(session: ClientSession | undefined, callback: Callback<ExecutionResult>): void;
    /** @internal */
    _getMore(batchSize: number, callback: Callback<Document>): void;
}
/** @internal */
export declare function assertUninitialized(cursor: AbstractCursor): void;
export {};
//# sourceMappingURL=abstract_cursor.d.ts.map