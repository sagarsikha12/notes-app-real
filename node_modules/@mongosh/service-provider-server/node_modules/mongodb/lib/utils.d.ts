/// <reference types="node" />
import { AnyError } from './error';
import { WriteConcern, WriteConcernOptions, W } from './write_concern';
import type { Server } from './sdam/server';
import type { Topology } from './sdam/topology';
import type { Db } from './db';
import type { Collection } from './collection';
import type { OperationOptions, Hint } from './operations/operation';
import { ReadConcern } from './read_concern';
import type { Connection } from './cmap/connection';
import { Document, ObjectId } from './bson';
import type { IndexSpecification } from './operations/indexes';
import type { Explain } from './explain';
import type { MongoClient } from './mongo_client';
import type { CommandOperationOptions, OperationParent } from './operations/command';
/**
 * MongoDB Driver style callback
 * @public
 */
export declare type Callback<T = any> = (error?: AnyError, result?: T) => void;
/** @public */
export declare type CallbackWithType<E = AnyError, T0 = any> = (error?: E, result?: T0) => void;
export declare const MAX_JS_INT: number;
export declare type AnyOptions = Document;
/**
 * Add a readonly enumerable property.
 * @internal
 */
export declare function getSingleProperty(obj: AnyOptions, name: string | number | symbol, value: unknown): void;
/**
 * Throws if collectionName is not a valid mongodb collection namespace.
 * @internal
 */
export declare function checkCollectionName(collectionName: string): void;
/**
 * Ensure Hint field is in a shape we expect:
 * - object of index names mapping to 1 or -1
 * - just an index name
 * @internal
 */
export declare function normalizeHintField(hint?: Hint): Hint | undefined;
interface IndexOptions {
    name: string;
    keys?: string[];
    fieldHash: Document;
}
/**
 * Create an index specifier based on
 * @internal
 */
export declare function parseIndexOptions(indexSpec: IndexSpecification): IndexOptions;
/**
 * Checks if arg is an Object:
 * - **NOTE**: the check is based on the `[Symbol.toStringTag]() === 'Object'`
 * @internal
 */
export declare function isObject(arg: unknown): arg is object;
/** @internal */
export declare function decorateCommand(command: Document, options: Document, exclude: string[]): Document;
/** @internal */
export declare function mergeOptions<T, S>(target: T, source: S): T & S;
/** @internal */
export declare function filterOptions(options: AnyOptions, names: string[]): AnyOptions;
/**
 * Executes the given operation with provided arguments.
 *
 * @remarks
 * This method reduces large amounts of duplication in the entire codebase by providing
 * a single point for determining whether callbacks or promises should be used. Additionally
 * it allows for a single point of entry to provide features such as implicit sessions, which
 * are required by the Driver Sessions specification in the event that a ClientSession is
 * not provided
 *
 * @internal
 *
 * @param topology - The topology to execute this operation on
 * @param operation - The operation to execute
 * @param args - Arguments to apply the provided operation
 * @param options - Options that modify the behavior of the method
 */
export declare function executeLegacyOperation(topology: Topology, operation: (...args: any[]) => void | Promise<Document>, args: any[], options?: AnyOptions): void | Promise<any>;
interface HasRetryableWrites {
    retryWrites?: boolean;
}
/**
 * Applies retryWrites: true to a command if retryWrites is set on the command's database.
 * @internal
 *
 * @param target - The target command to which we will apply retryWrites.
 * @param db - The database from which we can inherit a retryWrites value.
 */
export declare function applyRetryableWrites<T extends HasRetryableWrites>(target: T, db?: Db): T;
interface HasWriteConcern {
    writeConcern?: WriteConcernOptions | WriteConcern | W;
}
/**
 * Applies a write concern to a command based on well defined inheritance rules, optionally
 * detecting support for the write concern in the first place.
 * @internal
 *
 * @param target - the target command we will be applying the write concern to
 * @param sources - sources where we can inherit default write concerns from
 * @param options - optional settings passed into a command for write concern overrides
 */
export declare function applyWriteConcern<T extends HasWriteConcern>(target: T, sources: {
    db?: Db;
    collection?: Collection;
}, options?: OperationOptions & WriteConcernOptions): T;
/**
 * Checks if a given value is a Promise
 *
 * @typeParam T - The result type of maybePromise
 * @param maybePromise - An object that could be a promise
 * @returns true if the provided value is a Promise
 */
export declare function isPromiseLike<T = any>(maybePromise?: PromiseLike<T> | void): maybePromise is Promise<T>;
/**
 * Applies collation to a given command.
 * @internal
 *
 * @param command - the command on which to apply collation
 * @param target - target of command
 * @param options - options containing collation settings
 */
export declare function decorateWithCollation(command: Document, target: MongoClient | Db | Collection, options: AnyOptions): void;
/**
 * Applies a read concern to a given command.
 * @internal
 *
 * @param command - the command on which to apply the read concern
 * @param coll - the parent collection of the operation calling this method
 */
export declare function decorateWithReadConcern(command: Document, coll: {
    s: {
        readConcern?: ReadConcern;
    };
}, options?: OperationOptions): void;
/**
 * Applies an explain to a given command.
 * @internal
 *
 * @param command - the command on which to apply the explain
 * @param options - the options containing the explain verbosity
 */
export declare function decorateWithExplain(command: Document, explain: Explain): Document;
/**
 * A helper function to get the topology from a given provider. Throws
 * if the topology cannot be found.
 * @internal
 */
export declare function getTopology<T>(provider: MongoClient | Db | Collection<T>): Topology;
/**
 * Default message handler for generating deprecation warnings.
 * @internal
 *
 * @param name - function name
 * @param option - option name
 * @returns warning message
 */
export declare function defaultMsgHandler(name: string, option: string): string;
export interface DeprecateOptionsConfig {
    /** function name */
    name: string;
    /** options to deprecate */
    deprecatedOptions: string[];
    /** index of options object in function arguments array */
    optionsIndex: number;
    /** optional custom message handler to generate warnings */
    msgHandler?(name: string, option: string): string;
}
/**
 * Deprecates a given function's options.
 * @internal
 *
 * @param this - the bound class if this is a method
 * @param config - configuration for deprecation
 * @param fn - the target function of deprecation
 * @returns modified function that warns once per deprecated option, and executes original function
 */
export declare function deprecateOptions(this: unknown, config: DeprecateOptionsConfig, fn: (...args: any[]) => any): any;
/** @internal */
export declare function ns(ns: string): MongoDBNamespace;
/** @public */
export declare class MongoDBNamespace {
    db: string;
    collection?: string;
    /**
     * Create a namespace object
     *
     * @param db - database name
     * @param collection - collection name
     */
    constructor(db: string, collection?: string);
    toString(): string;
    withCollection(collection: string): MongoDBNamespace;
    static fromString(namespace?: string): MongoDBNamespace;
}
/** @internal */
export declare function makeCounter(seed?: number): Generator<number>;
/**
 * Helper function for either accepting a callback, or returning a promise
 * @internal
 *
 * @param callback - The last function argument in exposed method, controls if a Promise is returned
 * @param wrapper - A function that wraps the callback
 * @returns Returns void if a callback is supplied, else returns a Promise.
 */
export declare function maybePromise<T>(callback: Callback<T> | undefined, wrapper: (fn: Callback<T>) => void): Promise<T> | void;
/** @internal */
export declare function databaseNamespace(ns: string): string;
/** @internal */
export declare function collectionNamespace(ns: string): string;
/**
 * Synchronously Generate a UUIDv4
 * @internal
 */
export declare function uuidV4(): Buffer;
/**
 * A helper function for determining `maxWireVersion` between legacy and new topology instances
 * @internal
 */
export declare function maxWireVersion(topologyOrServer?: Connection | Topology | Server): number;
/**
 * Checks that collation is supported by server.
 * @internal
 *
 * @param server - to check against
 * @param cmd - object where collation may be specified
 */
export declare function collationNotSupported(server: Server, cmd: Document): boolean;
/**
 * Applies the function `eachFn` to each item in `arr`, in parallel.
 * @internal
 *
 * @param arr - An array of items to asynchronously iterate over
 * @param eachFn - A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.
 * @param callback - The callback called after every item has been iterated
 */
export declare function eachAsync<T = Document>(arr: T[], eachFn: (item: T, callback: (err?: AnyError) => void) => void, callback: Callback): void;
/** @internal */
export declare function eachAsyncSeries<T = any>(arr: T[], eachFn: (item: T, callback: (err?: AnyError) => void) => void, callback: Callback): void;
/** @internal */
export declare function arrayStrictEqual(arr: unknown[], arr2: unknown[]): boolean;
/** @internal */
export declare function errorStrictEqual(lhs?: AnyError, rhs?: AnyError): boolean;
interface StateTable {
    [key: string]: string[];
}
interface ObjectWithState {
    s: {
        state: string;
    };
    emit(event: 'stateChanged', state: string, newState: string): void;
}
interface StateTransitionFunction {
    (target: ObjectWithState, newState: string): void;
}
/** @public */
export declare type EventEmitterWithState = {
    /** @internal */
    stateChanged(previous: string, current: string): void;
};
/** @internal */
export declare function makeStateMachine(stateTable: StateTable): StateTransitionFunction;
/** @public */
export interface ClientMetadata {
    driver: {
        name: string;
        version: string;
    };
    os: {
        type: string;
        name: NodeJS.Platform;
        architecture: string;
        version: string;
    };
    platform: string;
    version?: string;
    application?: {
        name: string;
    };
}
/** @public */
export interface ClientMetadataOptions {
    driverInfo?: {
        name?: string;
        version?: string;
        platform?: string;
    };
    appName?: string;
}
export declare function makeClientMetadata(options?: ClientMetadataOptions): ClientMetadata;
/** @internal */
export declare function now(): number;
/** @internal */
export declare function calculateDurationInMs(started: number): number;
export interface InterruptibleAsyncIntervalOptions {
    /** The interval to execute a method on */
    interval: number;
    /** A minimum interval that must elapse before the method is called */
    minInterval: number;
    /** Whether the method should be called immediately when the interval is started  */
    immediate: boolean;
    /**
     * Only used for testing unreliable timer environments
     * @internal
     */
    clock: () => number;
}
/** @internal */
export interface InterruptibleAsyncInterval {
    wake(): void;
    stop(): void;
}
/**
 * Creates an interval timer which is able to be woken up sooner than
 * the interval. The timer will also debounce multiple calls to wake
 * ensuring that the function is only ever called once within a minimum
 * interval window.
 * @internal
 *
 * @param fn - An async function to run on an interval, must accept a `callback` as its only parameter
 */
export declare function makeInterruptibleAsyncInterval(fn: (callback: Callback) => void, options?: Partial<InterruptibleAsyncIntervalOptions>): InterruptibleAsyncInterval;
/** @internal */
export declare function hasAtomicOperators(doc: Document | Document[]): boolean;
/**
 * Merge inherited properties from parent into options, prioritizing values from options,
 * then values from parent.
 * @internal
 */
export declare function resolveOptions<T extends CommandOperationOptions>(parent: OperationParent | undefined, options?: T): T;
export declare function isSuperset(set: Set<any> | any[], subset: Set<any> | any[]): boolean;
export declare function setDifference(setA: Iterable<any>, setB: Iterable<any>): Set<any>;
export declare function isRecord<T extends readonly string[]>(value: unknown, requiredKeys: T): value is Record<T[number], any>;
export declare function isRecord(value: unknown): value is Record<string, any>;
/**
 * Make a deep copy of an object
 *
 * NOTE: This is not meant to be the perfect implementation of a deep copy,
 * but instead something that is good enough for the purposes of
 * command monitoring.
 */
export declare function deepCopy<T extends any>(value: T): T;
/** @internal */
declare const kBuffers: unique symbol;
/** @internal */
declare const kLength: unique symbol;
/**
 * A pool of Buffers which allow you to read them as if they were one
 * @internal
 */
export declare class BufferPool {
    [kBuffers]: Buffer[];
    [kLength]: number;
    constructor();
    get length(): number;
    /** Adds a buffer to the internal buffer pool list */
    append(buffer: Buffer): void;
    /** Returns the requested number of bytes without consuming them */
    peek(size: number): Buffer;
    /** Reads the requested number of bytes, optionally consuming them */
    read(size: number, consume?: boolean): Buffer;
}
/** @public */
export declare class HostAddress {
    host: string | undefined;
    port: number | undefined;
    socketPath: string | undefined;
    isIPv6: boolean | undefined;
    constructor(hostString: string);
    /**
     * @param ipv6Brackets - optionally request ipv6 bracket notation required for connection strings
     */
    toString(ipv6Brackets?: boolean): string;
    static fromString(s: string): HostAddress;
}
export declare const DEFAULT_PK_FACTORY: {
    createPk(): ObjectId;
};
/**
 * When the driver used emitWarning the code will be equal to this.
 * @public
 *
 * @example
 * ```js
 * process.on('warning', (warning) => {
 *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')
 * })
 * ```
 */
export declare const MONGODB_WARNING_CODE: "MONGODB DRIVER";
/** @internal */
export declare function emitWarning(message: string): void;
/**
 * Will emit a warning once for the duration of the application.
 * Uses the message to identify if it has already been emitted
 * so using string interpolation can cause multiple emits
 * @internal
 */
export declare function emitWarningOnce(message: string): void;
export {};
//# sourceMappingURL=utils.d.ts.map