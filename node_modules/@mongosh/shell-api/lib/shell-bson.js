"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const enums_1 = require("./enums");
const help_1 = __importDefault(require("./help"));
const service_provider_core_1 = require("@mongosh/service-provider-core");
const errors_1 = require("@mongosh/errors");
const helpers_1 = require("./helpers");
const crypto_1 = require("crypto");
function constructHelp(className) {
    const classHelpKeyPrefix = `shell-api.classes.${className}.help`;
    const classHelp = {
        help: `${classHelpKeyPrefix}.description`,
        example: `${classHelpKeyPrefix}.example`,
        docs: `${classHelpKeyPrefix}.link`,
        attr: []
    };
    return new help_1.default(classHelp);
}
function constructShellBson(bson, printWarning) {
    const bsonNames = [
        'Binary', 'Code', 'DBRef', 'Decimal128', 'Double', 'Int32', 'Long',
        'MaxKey', 'MinKey', 'ObjectId', 'Timestamp', 'Map', 'BSONSymbol',
        'BSONRegExp'
    ];
    if (bson === undefined) {
        bson = service_provider_core_1.bson;
    }
    const helps = {};
    bsonNames.forEach((className) => {
        if (!(className in bson)) {
            throw new errors_1.MongoshInternalError(`${className} does not exist in provided BSON package.`);
        }
        const proto = bson[className].prototype;
        proto.serverVersions = enums_1.ALL_SERVER_VERSIONS;
        proto.platforms = enums_1.ALL_PLATFORMS;
        proto.topologies = enums_1.ALL_TOPOLOGIES;
        const help = constructHelp(className);
        helps[className] = help;
        proto.help = () => (help);
        Object.setPrototypeOf(proto.help, help);
    });
    bson.BSONSymbol.prototype.serverVersions = [enums_1.ServerVersions.earliest, '1.6.0'];
    bson.BSONSymbol.prototype.deprecated = true;
    const bsonPkg = {
        DBRef: Object.assign(function DBRef(namespace, oid, db, fields) {
            helpers_1.assertArgsDefinedType([namespace, oid, db], ['string', true, [undefined, 'string'], [undefined, 'object']], 'DBRef');
            return new bson.DBRef(namespace, oid, db, fields);
        }, { ...bson.DBRef, prototype: bson.DBRef.prototype }),
        Map: bson.Map,
        bsonsize: function bsonsize(object) {
            helpers_1.assertArgsDefinedType([object], ['object'], 'bsonsize');
            return bson.calculateObjectSize(object);
        },
        MaxKey: Object.assign(function MaxKey() {
            return new bson.MaxKey();
        }, { ...bson.MaxKey, prototype: bson.MaxKey.prototype }),
        MinKey: Object.assign(function MinKey() {
            return new bson.MinKey();
        }, { ...bson.MinKey, prototype: bson.MinKey.prototype }),
        ObjectId: Object.assign(function ObjectId(id) {
            helpers_1.assertArgsDefinedType([id], [[undefined, 'string', 'number', 'object']], 'ObjectId');
            return new bson.ObjectId(id);
        }, { ...bson.ObjectId, prototype: bson.ObjectId.prototype }),
        Timestamp: Object.assign(function Timestamp(low, high) {
            helpers_1.assertArgsDefinedType([low, high], [['number', 'object', undefined], [undefined, 'number']], 'Timestamp');
            return new bson.Timestamp(low, high);
        }, { ...bson.Timestamp, prototype: bson.Timestamp.prototype }),
        Code: Object.assign(function Code(c = '', s) {
            helpers_1.assertArgsDefinedType([c, s], [[undefined, 'string', 'function'], [undefined, 'object']], 'Code');
            return new bson.Code(c, s);
        }, { ...bson.Code, prototype: bson.Code.prototype }),
        NumberDecimal: Object.assign(function (s = '0') {
            helpers_1.assertArgsDefinedType([s], [['string', 'number']], 'NumberDecimal');
            if (typeof s === 'string') {
                return bson.Decimal128.fromString(s);
            }
            printWarning('NumberDecimal: specifying a number as argument is deprecated and may lead to loss of precision');
            return bson.Decimal128.fromString(`${s}`);
        }, { prototype: bson.Decimal128.prototype }),
        NumberInt: Object.assign(function (v = '0') {
            helpers_1.assertArgsDefinedType([v], [['string', 'number']], 'NumberInt');
            return new bson.Int32(parseInt(`${v}`, 10));
        }, { prototype: bson.Int32.prototype }),
        NumberLong: Object.assign(function (s = '0') {
            helpers_1.assertArgsDefinedType([s], [['string', 'number']], 'NumberLong');
            if (typeof s === 'string') {
                return bson.Long.fromString(s);
            }
            printWarning('NumberLong: specifying a number as argument is deprecated and may lead to loss of precision');
            return bson.Long.fromInt(s);
        }, { prototype: bson.Long.prototype }),
        ISODate: function (input) {
            if (!input)
                input = new Date().toISOString();
            const isoDateRegex = /^(?<Y>\d{4})-?(?<M>\d{2})-?(?<D>\d{2})([T ](?<h>\d{2})(:?(?<m>\d{2})(:?((?<s>\d{2})(\.(?<ms>\d+))?))?)?(?<tz>Z|([+-])(\d{2}):?(\d{2})?)?)?$/;
            const match = input.match(isoDateRegex);
            if (match !== null && match.groups !== undefined) {
                const { Y, M, D, h, m, s, ms, tz } = match.groups;
                const normalized = `${Y}-${M}-${D}T${h || '00'}:${m || '00'}:${s || '00'}.${ms || '000'}${tz || 'Z'}`;
                const date = new Date(normalized);
                if (date.getTime() >= -62167219200000 && date.getTime() <= 253402300799999) {
                    return date;
                }
            }
            throw new errors_1.MongoshInvalidInputError(`${JSON.stringify(input)} is not a valid ISODate`, errors_1.CommonErrors.InvalidArgument);
        },
        BinData: Object.assign(function (subtype, b64string) {
            helpers_1.assertArgsDefinedType([subtype, b64string], ['number', 'string'], 'BinData');
            const buffer = Buffer.from(b64string, 'base64');
            return new bson.Binary(buffer, subtype);
        }, { prototype: bson.Binary.prototype }),
        HexData: Object.assign(function (subtype, hexstr) {
            helpers_1.assertArgsDefinedType([subtype, hexstr], ['number', 'string'], 'HexData');
            const buffer = Buffer.from(hexstr, 'hex');
            return new bson.Binary(buffer, subtype);
        }, { prototype: bson.Binary.prototype }),
        UUID: Object.assign(function (hexstr) {
            if (hexstr === undefined) {
                const uuid = crypto_1.randomBytes(16);
                uuid[6] = (uuid[6] & 0x0f) | 0x40;
                uuid[8] = (uuid[8] & 0x3f) | 0x80;
                hexstr = uuid.toString('hex');
            }
            helpers_1.assertArgsDefinedType([hexstr], ['string'], 'UUID');
            const buffer = Buffer.from(hexstr.replace(/-/g, ''), 'hex');
            return new bson.Binary(buffer, bson.Binary.SUBTYPE_UUID);
        }, { prototype: bson.Binary.prototype }),
        MD5: Object.assign(function (hexstr) {
            helpers_1.assertArgsDefinedType([hexstr], ['string'], 'MD5');
            const buffer = Buffer.from(hexstr, 'hex');
            return new bson.Binary(buffer, bson.Binary.SUBTYPE_MD5);
        }, { prototype: bson.Binary.prototype }),
        Decimal128: bson.Decimal128,
        BSONSymbol: bson.BSONSymbol,
        Int32: bson.Int32,
        Long: bson.Long,
        Binary: bson.Binary,
        Double: bson.Double,
        EJSON: bson.EJSON,
        BSONRegExp: bson.BSONRegExp
    };
    Object.keys(bsonPkg).forEach((className) => {
        const help = helps[className] || constructHelp(className);
        bsonPkg[className].help = () => (help);
        Object.setPrototypeOf(bsonPkg[className].help, help);
    });
    return bsonPkg;
}
exports.default = constructShellBson;
//# sourceMappingURL=shell-bson.js.map