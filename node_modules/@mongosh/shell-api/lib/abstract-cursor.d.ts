import { ShellApiWithMongoClass } from './decorators';
import type Mongo from './mongo';
import type { Document, ExplainVerbosityLike, FindCursor as ServiceProviderCursor, AggregationCursor as ServiceProviderAggregationCursor } from '@mongosh/service-provider-core';
import { asPrintable } from './enums';
import { CursorIterationResult } from './result';
export declare abstract class AbstractCursor<CursorType extends ServiceProviderAggregationCursor | ServiceProviderCursor> extends ShellApiWithMongoClass {
    _mongo: Mongo;
    _cursor: CursorType;
    _currentIterationResult: CursorIterationResult | null;
    _mapError: Error | null;
    constructor(mongo: Mongo, cursor: CursorType);
    _withCheckMapError<Ret>(fn: () => Ret): Promise<Ret>;
    [asPrintable](): Promise<CursorIterationResult>;
    _it(): Promise<CursorIterationResult>;
    batchSize(size: number): this;
    close(options: Document): Promise<void>;
    forEach(f: (doc: Document) => void): Promise<void>;
    hasNext(): Promise<boolean>;
    tryNext(): Promise<Document | null>;
    [Symbol.asyncIterator](): AsyncGenerator<Document, void, unknown>;
    isClosed(): boolean;
    isExhausted(): boolean;
    itcount(): Promise<number>;
    toArray(): Promise<Document[]>;
    pretty(): this;
    map(f: (doc: Document) => Document): this;
    maxTimeMS(value: number): this;
    next(): Promise<Document | null>;
    projection(spec: Document): this;
    skip(value: number): this;
    sort(spec: Document): this;
    objsLeftInBatch(): number;
    explain(verbosity?: ExplainVerbosityLike): Promise<any>;
}
