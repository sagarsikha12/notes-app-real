"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShellEvaluator = void 0;
const shell_api_1 = require("@mongosh/shell-api");
const async_rewriter2_1 = __importDefault(require("@mongosh/async-rewriter2"));
const history_1 = require("@mongosh/history");
class ShellEvaluator {
    constructor(internalState, resultHandler = shell_api_1.toShellResult) {
        this.hasAppliedAsyncWriterRuntimeSupport = true;
        this.internalState = internalState;
        this.resultHandler = resultHandler;
        this.asyncWriter = new async_rewriter2_1.default();
        this.hasAppliedAsyncWriterRuntimeSupport = false;
    }
    async innerEval(originalEval, input, context, filename) {
        var _a, _b;
        const { shellApi } = this.internalState;
        const argv = input.trim().replace(/;$/, '').split(/\s+/g);
        const cmd = argv.shift();
        if (((_a = shellApi[cmd]) === null || _a === void 0 ? void 0 : _a.isDirectShellCommand) && !((_b = argv[0]) !== null && _b !== void 0 ? _b : '').startsWith('(')) {
            return shellApi[cmd](...argv);
        }
        let rewrittenInput = this.asyncWriter.process(input);
        const hiddenCommands = RegExp(history_1.HIDDEN_COMMANDS, 'g');
        if (!hiddenCommands.test(input) && !hiddenCommands.test(rewrittenInput)) {
            this.internalState.messageBus.emit('mongosh:evaluate-input', { input: history_1.redactSensitiveData(input.trim()) });
        }
        if (!this.hasAppliedAsyncWriterRuntimeSupport) {
            this.hasAppliedAsyncWriterRuntimeSupport = true;
            const supportCode = this.asyncWriter.runtimeSupportCode();
            eval(supportCode);
            rewrittenInput = supportCode + ';\n' + rewrittenInput;
        }
        try {
            return await originalEval(rewrittenInput, context, filename);
        }
        catch (err) {
            throw this.internalState.transformError(err);
        }
    }
    async customEval(originalEval, input, context, filename) {
        const evaluationResult = await this.innerEval(originalEval, input, context, filename);
        return await this.resultHandler(evaluationResult);
    }
}
exports.ShellEvaluator = ShellEvaluator;
//# sourceMappingURL=shell-evaluator.js.map