import { AbstractOperation, OperationOptions } from './operation';
import { ReadConcern } from '../read_concern';
import { WriteConcern, WriteConcernOptions } from '../write_concern';
import { MongoDBNamespace, Callback } from '../utils';
import type { ReadPreference } from '../read_preference';
import { ClientSession } from '../sessions';
import type { Logger } from '../logger';
import type { Server } from '../sdam/server';
import type { BSONSerializeOptions, Document } from '../bson';
import type { ReadConcernLike } from './../read_concern';
import { Explain, ExplainOptions } from '../explain';
/** @public */
export interface CollationOptions {
    locale: string;
    caseLevel?: boolean;
    caseFirst?: string;
    strength?: number;
    numericOrdering?: boolean;
    alternate?: string;
    maxVariable?: string;
    backwards?: boolean;
    normalization?: boolean;
}
/** @public */
export interface CommandOperationOptions extends OperationOptions, WriteConcernOptions, ExplainOptions {
    /** Return the full server response for the command */
    fullResponse?: boolean;
    /** Specify a read concern and level for the collection. (only MongoDB 3.2 or higher supported) */
    readConcern?: ReadConcernLike;
    /** Collation */
    collation?: CollationOptions;
    maxTimeMS?: number;
    /** A user-provided comment to attach to this command */
    comment?: string | Document;
    /** Should retry failed writes */
    retryWrites?: boolean;
    dbName?: string;
    authdb?: string;
    noResponse?: boolean;
}
/** @internal */
export interface OperationParent {
    s: {
        namespace: MongoDBNamespace;
    };
    readConcern?: ReadConcern;
    writeConcern?: WriteConcern;
    readPreference?: ReadPreference;
    logger?: Logger;
    bsonOptions?: BSONSerializeOptions;
}
/** @internal */
export declare abstract class CommandOperation<T> extends AbstractOperation<T> {
    options: CommandOperationOptions;
    ns: MongoDBNamespace;
    readConcern?: ReadConcern;
    writeConcern?: WriteConcern;
    explain?: Explain;
    fullResponse?: boolean;
    logger?: Logger;
    constructor(parent?: OperationParent, options?: CommandOperationOptions);
    get canRetryWrite(): boolean;
    abstract execute(server: Server, session: ClientSession, callback: Callback<T>): void;
    executeCommand(server: Server, session: ClientSession, cmd: Document, callback: Callback): void;
}
//# sourceMappingURL=command.d.ts.map