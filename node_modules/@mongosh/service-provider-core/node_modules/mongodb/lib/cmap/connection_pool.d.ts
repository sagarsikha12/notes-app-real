/// <reference types="node" />
import Denque = require('denque');
import { Connection, ConnectionEvents, ConnectionOptions } from './connection';
import type { ObjectId } from 'bson';
import { Logger } from '../logger';
import { ConnectionPoolMetrics } from './metrics';
import type { ClientSession } from '../sessions';
import { Callback } from '../utils';
import { MongoError } from '../error';
import { ConnectionPoolCreatedEvent, ConnectionPoolClosedEvent, ConnectionCreatedEvent, ConnectionReadyEvent, ConnectionClosedEvent, ConnectionCheckOutStartedEvent, ConnectionCheckOutFailedEvent, ConnectionCheckedOutEvent, ConnectionCheckedInEvent, ConnectionPoolClearedEvent } from './connection_pool_events';
import { CancellationToken, TypedEventEmitter } from '../mongo_types';
/** @internal */
declare const kLogger: unique symbol;
/** @internal */
declare const kConnections: unique symbol;
/** @internal */
declare const kPermits: unique symbol;
/** @internal */
declare const kMinPoolSizeTimer: unique symbol;
/** @internal */
declare const kGeneration: unique symbol;
/** @internal */
declare const kServiceGenerations: unique symbol;
/** @internal */
declare const kConnectionCounter: unique symbol;
/** @internal */
declare const kCancellationToken: unique symbol;
/** @internal */
declare const kWaitQueue: unique symbol;
/** @internal */
declare const kCancelled: unique symbol;
/** @internal */
declare const kMetrics: unique symbol;
/** @internal */
declare const kCheckedOut: unique symbol;
/** @public */
export interface ConnectionPoolOptions extends Omit<ConnectionOptions, 'id' | 'generation'> {
    /** The maximum number of connections that may be associated with a pool at a given time. This includes in use and available connections. */
    maxPoolSize: number;
    /** The minimum number of connections that MUST exist at any moment in a single connection pool. */
    minPoolSize: number;
    /** The maximum amount of time a connection should remain idle in the connection pool before being marked idle. */
    maxIdleTimeMS: number;
    /** The maximum amount of time operation execution should wait for a connection to become available. The default is 0 which means there is no limit. */
    waitQueueTimeoutMS: number;
    /** If we are in load balancer mode. */
    loadBalanced: boolean;
}
/** @internal */
export interface WaitQueueMember {
    callback: Callback<Connection>;
    timer?: NodeJS.Timeout;
    [kCancelled]?: boolean;
}
/** @public */
export interface CloseOptions {
    force?: boolean;
}
/** @public */
export declare type ConnectionPoolEvents = {
    connectionPoolCreated(event: ConnectionPoolCreatedEvent): void;
    connectionPoolClosed(event: ConnectionPoolClosedEvent): void;
    connectionPoolCleared(event: ConnectionPoolClearedEvent): void;
    connectionCreated(event: ConnectionCreatedEvent): void;
    connectionReady(event: ConnectionReadyEvent): void;
    connectionClosed(event: ConnectionClosedEvent): void;
    connectionCheckOutStarted(event: ConnectionCheckOutStartedEvent): void;
    connectionCheckOutFailed(event: ConnectionCheckOutFailedEvent): void;
    connectionCheckedOut(event: ConnectionCheckedOutEvent): void;
    connectionCheckedIn(event: ConnectionCheckedInEvent): void;
} & Omit<ConnectionEvents, 'close' | 'message'>;
/**
 * A pool of connections which dynamically resizes, and emit events related to pool activity
 * @internal
 */
export declare class ConnectionPool extends TypedEventEmitter<ConnectionPoolEvents> {
    closed: boolean;
    options: Readonly<ConnectionPoolOptions>;
    /** @internal */
    [kLogger]: Logger;
    /** @internal */
    [kConnections]: Denque<Connection>;
    /**
     * An integer expressing how many total connections are permitted
     * @internal
     */
    [kPermits]: number;
    /** @internal */
    [kMinPoolSizeTimer]?: NodeJS.Timeout;
    /**
     * An integer representing the SDAM generation of the pool
     * @internal
     */
    [kGeneration]: number;
    /** A map of generations to service ids
     * @internal
     */
    [kServiceGenerations]: Map<ObjectId, number>;
    /** @internal */
    [kConnectionCounter]: Generator<number>;
    /** @internal */
    [kCancellationToken]: CancellationToken;
    /** @internal */
    [kWaitQueue]: Denque<WaitQueueMember>;
    /** @internal */
    [kMetrics]: ConnectionPoolMetrics;
    /** @internal */
    [kCheckedOut]: number;
    /**
     * Emitted when the connection pool is created.
     * @event
     */
    static readonly CONNECTION_POOL_CREATED: "connectionPoolCreated";
    /**
     * Emitted once when the connection pool is closed
     * @event
     */
    static readonly CONNECTION_POOL_CLOSED: "connectionPoolClosed";
    /**
     * Emitted each time the connection pool is cleared and it's generation incremented
     * @event
     */
    static readonly CONNECTION_POOL_CLEARED: "connectionPoolCleared";
    /**
     * Emitted when a connection is created.
     * @event
     */
    static readonly CONNECTION_CREATED: "connectionCreated";
    /**
     * Emitted when a connection becomes established, and is ready to use
     * @event
     */
    static readonly CONNECTION_READY: "connectionReady";
    /**
     * Emitted when a connection is closed
     * @event
     */
    static readonly CONNECTION_CLOSED: "connectionClosed";
    /**
     * Emitted when an attempt to check out a connection begins
     * @event
     */
    static readonly CONNECTION_CHECK_OUT_STARTED: "connectionCheckOutStarted";
    /**
     * Emitted when an attempt to check out a connection fails
     * @event
     */
    static readonly CONNECTION_CHECK_OUT_FAILED: "connectionCheckOutFailed";
    /**
     * Emitted each time a connection is successfully checked out of the connection pool
     * @event
     */
    static readonly CONNECTION_CHECKED_OUT: "connectionCheckedOut";
    /**
     * Emitted each time a connection is successfully checked into the connection pool
     * @event
     */
    static readonly CONNECTION_CHECKED_IN: "connectionCheckedIn";
    /** @internal */
    constructor(options: ConnectionPoolOptions);
    /** The address of the endpoint the pool is connected to */
    get address(): string;
    /** An integer representing the SDAM generation of the pool */
    get generation(): number;
    /** An integer expressing how many total connections (active + in use) the pool currently has */
    get totalConnectionCount(): number;
    /** An integer expressing how many connections are currently available in the pool. */
    get availableConnectionCount(): number;
    get waitQueueSize(): number;
    get loadBalanced(): boolean;
    get serviceGenerations(): Map<ObjectId, number>;
    get currentCheckedOutCount(): number;
    markPinned(connection: Connection, pinType: string): void;
    markUnpinned(connection: Connection, pinType: string): void;
    /**
     * Get the metrics information for the pool when a wait queue timeout occurs.
     */
    waitQueueErrorMetrics(): string;
    /**
     * Check a connection out of this pool. The connection will continue to be tracked, but no reference to it
     * will be held by the pool. This means that if a connection is checked out it MUST be checked back in or
     * explicitly destroyed by the new owner.
     */
    checkOut(callback: Callback<Connection>): void;
    /**
     * Check a connection into the pool.
     *
     * @param connection - The connection to check in
     */
    checkIn(connection: Connection): void;
    /**
     * Clear the pool
     *
     * Pool reset is handled by incrementing the pool's generation count. Any existing connection of a
     * previous generation will eventually be pruned during subsequent checkouts.
     */
    clear(serviceId?: ObjectId): void;
    /** Close the pool */
    close(callback: Callback<void>): void;
    close(options: CloseOptions, callback: Callback<void>): void;
    /**
     * Runs a lambda with an implicitly checked out connection, checking that connection back in when the lambda
     * has completed by calling back.
     *
     * NOTE: please note the required signature of `fn`
     *
     * @param fn - A function which operates on a managed connection
     * @param callback - The original callback
     */
    withConnection(fn: WithConnectionCallback, callback?: Callback<Connection>): void;
    /**
     * Executes a function against a pinned connection. If a pinned connection is
     * already on the session, then it will use that connection. If not a new
     * connection will be checked out and pinned to the session. Check ins are to
     * be handled separately when the operations fully complete.
     *
     * @param session - The client session.
     * @param fn - A function which operates on a managed connection
     * @param callback - The original callback
     */
    withPinnedConnection(session: ClientSession, fn: WithConnectionCallback, callback?: Callback<Connection>): void;
}
export declare const CMAP_EVENTS: readonly ["connectionPoolCreated", "connectionPoolClosed", "connectionCreated", "connectionReady", "connectionClosed", "connectionCheckOutStarted", "connectionCheckOutFailed", "connectionCheckedOut", "connectionCheckedIn", "connectionPoolCleared"];
/**
 * A callback provided to `withConnection`
 * @internal
 *
 * @param error - An error instance representing the error during the execution.
 * @param connection - The managed connection which was checked out of the pool.
 * @param callback - A function to call back after connection management is complete
 */
export declare type WithConnectionCallback = (error: MongoError, connection: Connection | undefined, callback: Callback<Connection>) => void;
export {};
//# sourceMappingURL=connection_pool.d.ts.map