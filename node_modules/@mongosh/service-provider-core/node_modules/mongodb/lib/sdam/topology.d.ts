/// <reference types="node" />
import Denque = require('denque');
import { ReadPreference, ReadPreferenceLike } from '../read_preference';
import { ServerDescription } from './server_description';
import { TopologyDescription } from './topology_description';
import { Server, ServerEvents, ServerOptions } from './server';
import { ClientSession, ServerSessionPool, ServerSessionId, ClientSessionOptions } from '../sessions';
import { SrvPoller, SrvPollingEvent } from './srv_polling';
import { ConnectionPoolEvents } from '../cmap/connection_pool';
import { ServerSelector } from './server_selection';
import { ClientMetadata, Callback, HostAddress, EventEmitterWithState } from '../utils';
import { ClusterTime, TimerQueue } from './common';
import { ServerOpeningEvent, ServerClosedEvent, ServerDescriptionChangedEvent, TopologyOpeningEvent, TopologyClosedEvent, TopologyDescriptionChangedEvent } from './events';
import type { Document, BSONSerializeOptions } from '../bson';
import type { MongoCredentials } from '../cmap/auth/mongo_credentials';
import type { Transaction } from '../transactions';
import type { CloseOptions } from '../cmap/connection_pool';
import { ConnectionEvents } from '../cmap/connection';
import type { MongoOptions, ServerApi } from '../mongo_client';
import { serialize, deserialize } from '../bson';
import { TypedEventEmitter } from '../mongo_types';
/** @internal */
declare const kCancelled: unique symbol;
/** @internal */
declare const kWaitQueue: unique symbol;
/** @internal */
export declare type ServerSelectionCallback = Callback<Server>;
/** @internal */
export interface ServerSelectionRequest {
    serverSelector: ServerSelector;
    transaction?: Transaction;
    callback: ServerSelectionCallback;
    timer?: NodeJS.Timeout;
    [kCancelled]?: boolean;
}
/** @internal */
export interface TopologyPrivate {
    /** the id of this topology */
    id: number;
    /** passed in options */
    options: TopologyOptions;
    /** initial seedlist of servers to connect to */
    seedlist: HostAddress[];
    /** initial state */
    state: string;
    /** the topology description */
    description: TopologyDescription;
    serverSelectionTimeoutMS: number;
    heartbeatFrequencyMS: number;
    minHeartbeatFrequencyMS: number;
    /** A map of server instances to normalized addresses */
    servers: Map<string, Server>;
    /** Server Session Pool */
    sessionPool: ServerSessionPool;
    /** Active client sessions */
    sessions: Set<ClientSession>;
    credentials?: MongoCredentials;
    clusterTime?: ClusterTime;
    /** timers created for the initial connect to a server */
    connectionTimers: TimerQueue;
    /** related to srv polling */
    srvPoller?: SrvPoller;
    detectShardedTopology: (event: TopologyDescriptionChangedEvent) => void;
    detectSrvRecords: (event: SrvPollingEvent) => void;
}
/** @public */
export interface TopologyOptions extends BSONSerializeOptions, ServerOptions {
    hosts: HostAddress[];
    retryWrites: boolean;
    retryReads: boolean;
    /** How long to block for server selection before throwing an error */
    serverSelectionTimeoutMS: number;
    /** The name of the replica set to connect to */
    replicaSet?: string;
    srvHost?: string;
    /** @internal */
    srvPoller?: SrvPoller;
    /** Indicates that a client should directly connect to a node without attempting to discover its topology type */
    directConnection: boolean;
    loadBalanced: boolean;
    metadata: ClientMetadata;
    /** MongoDB server API version */
    serverApi?: ServerApi;
}
/** @public */
export interface ConnectOptions {
    readPreference?: ReadPreference;
}
/** @public */
export interface SelectServerOptions {
    readPreference?: ReadPreferenceLike;
    /** How long to block for server selection before throwing an error */
    serverSelectionTimeoutMS?: number;
    session?: ClientSession;
}
/** @public */
export declare type TopologyEvents = {
    /** Top level MongoClient doesn't emit this so it is marked: @internal */
    connect(topology: Topology): void;
    serverOpening(event: ServerOpeningEvent): void;
    serverClosed(event: ServerClosedEvent): void;
    serverDescriptionChanged(event: ServerDescriptionChangedEvent): void;
    topologyClosed(event: TopologyClosedEvent): void;
    topologyOpening(event: TopologyOpeningEvent): void;
    topologyDescriptionChanged(event: TopologyDescriptionChangedEvent): void;
    error(error: Error): void;
    /** TODO(NODE-3273) - remove error @internal */
    open(error: undefined, topology: Topology): void;
    close(): void;
    timeout(): void;
} & Omit<ServerEvents, 'connect'> & ConnectionPoolEvents & ConnectionEvents & EventEmitterWithState;
/**
 * A container of server instances representing a connection to a MongoDB topology.
 * @internal
 */
export declare class Topology extends TypedEventEmitter<TopologyEvents> {
    /** @internal */
    s: TopologyPrivate;
    /** @internal */
    [kWaitQueue]: Denque<ServerSelectionRequest>;
    /** @internal */
    ismaster?: Document;
    /** @internal */
    _type?: string;
    /** @event */
    static readonly SERVER_OPENING: "serverOpening";
    /** @event */
    static readonly SERVER_CLOSED: "serverClosed";
    /** @event */
    static readonly SERVER_DESCRIPTION_CHANGED: "serverDescriptionChanged";
    /** @event */
    static readonly TOPOLOGY_OPENING: "topologyOpening";
    /** @event */
    static readonly TOPOLOGY_CLOSED: "topologyClosed";
    /** @event */
    static readonly TOPOLOGY_DESCRIPTION_CHANGED: "topologyDescriptionChanged";
    /** @event */
    static readonly ERROR: "error";
    /** @event */
    static readonly OPEN: "open";
    /** @event */
    static readonly CONNECT: "connect";
    /** @event */
    static readonly CLOSE: "close";
    /** @event */
    static readonly TIMEOUT: "timeout";
    /**
     * @internal
     *
     * @privateRemarks
     * mongodb-client-encryption's class ClientEncryption falls back to finding the bson lib
     * defined on client.topology.bson, in order to maintain compatibility with any version
     * of mongodb-client-encryption we keep a reference to serialize and deserialize here.
     */
    bson: {
        serialize: typeof serialize;
        deserialize: typeof deserialize;
    };
    /**
     * @param seedlist - a list of HostAddress instances to connect to
     */
    constructor(seeds: string | string[] | HostAddress | HostAddress[], options: TopologyOptions);
    private detectShardedTopology;
    private detectSrvRecords;
    /**
     * @returns A `TopologyDescription` for this topology
     */
    get description(): TopologyDescription;
    get loadBalanced(): boolean;
    capabilities(): ServerCapabilities;
    /** Initiate server connect */
    connect(options?: ConnectOptions, callback?: Callback): void;
    /** Close this topology */
    close(options?: CloseOptions, callback?: Callback): void;
    /**
     * Selects a server according to the selection predicate provided
     *
     * @param selector - An optional selector to select servers by, defaults to a random selection within a latency window
     * @param options - Optional settings related to server selection
     * @param callback - The callback used to indicate success or failure
     * @returns An instance of a `Server` meeting the criteria of the predicate provided
     */
    selectServer(options: SelectServerOptions, callback: Callback<Server>): void;
    selectServer(selector: string | ReadPreference | ServerSelector, callback: Callback<Server>): void;
    selectServer(selector: string | ReadPreference | ServerSelector, options: SelectServerOptions, callback: Callback<Server>): void;
    /**
     * @returns Whether the topology should initiate selection to determine session support
     */
    shouldCheckForSessionSupport(): boolean;
    /**
     * @returns Whether sessions are supported on the current topology
     */
    hasSessionSupport(): boolean;
    /** Start a logical session */
    startSession(options: ClientSessionOptions, clientOptions?: MongoOptions): ClientSession;
    /** Send endSessions command(s) with the given session ids */
    endSessions(sessions: ServerSessionId[], callback?: Callback<Document>): void;
    /**
     * Update the internal TopologyDescription with a ServerDescription
     *
     * @param serverDescription - The server to update in the internal list of server descriptions
     */
    serverUpdateHandler(serverDescription: ServerDescription): void;
    auth(credentials?: MongoCredentials, callback?: Callback): void;
    get clientMetadata(): ClientMetadata;
    isConnected(): boolean;
    isDestroyed(): boolean;
    unref(): void;
    lastIsMaster(): Document;
    get logicalSessionTimeoutMinutes(): number | undefined;
    get clusterTime(): ClusterTime | undefined;
    set clusterTime(clusterTime: ClusterTime | undefined);
}
/** @public */
export declare const TOPOLOGY_EVENTS: ("error" | "close" | "timeout" | "serverOpening" | "serverClosed" | "serverDescriptionChanged" | "topologyOpening" | "topologyClosed" | "topologyDescriptionChanged")[];
/** @public */
export declare class ServerCapabilities {
    maxWireVersion: number;
    minWireVersion: number;
    constructor(ismaster: Document);
    get hasAggregationCursor(): boolean;
    get hasWriteCommands(): boolean;
    get hasTextSearch(): boolean;
    get hasAuthCommands(): boolean;
    get hasListCollectionsCommand(): boolean;
    get hasListIndexesCommand(): boolean;
    get commandsTakeWriteConcern(): boolean;
    get commandsTakeCollation(): boolean;
}
export {};
//# sourceMappingURL=topology.d.ts.map