import type { TopologyVersion } from './sdam/server_description';
import type { Document } from './bson';
import type { TopologyDescription } from './sdam/topology_description';
/** @public */
export declare type AnyError = MongoError | Error;
/** @internal */
declare const kErrorLabels: unique symbol;
/** @internal MongoDB Error Codes */
export declare const MONGODB_ERROR_CODES: Readonly<{
    readonly HostUnreachable: 6;
    readonly HostNotFound: 7;
    readonly NetworkTimeout: 89;
    readonly ShutdownInProgress: 91;
    readonly PrimarySteppedDown: 189;
    readonly ExceededTimeLimit: 262;
    readonly SocketException: 9001;
    readonly NotMaster: 10107;
    readonly InterruptedAtShutdown: 11600;
    readonly InterruptedDueToReplStateChange: 11602;
    readonly NotMasterNoSlaveOk: 13435;
    readonly NotMasterOrSecondary: 13436;
    readonly StaleShardVersion: 63;
    readonly StaleEpoch: 150;
    readonly StaleConfig: 13388;
    readonly RetryChangeStream: 234;
    readonly FailedToSatisfyReadPreference: 133;
    readonly CursorNotFound: 43;
    readonly LegacyNotPrimary: 10058;
    readonly WriteConcernFailed: 64;
    readonly NamespaceNotFound: 26;
    readonly IllegalOperation: 20;
    readonly MaxTimeMSExpired: 50;
    readonly UnknownReplWriteConcern: 79;
    readonly UnsatisfiableWriteConcern: 100;
}>;
export declare const GET_MORE_RESUMABLE_CODES: Set<number>;
/** @public */
export interface ErrorDescription {
    message?: string;
    errmsg?: string;
    $err?: string;
    errorLabels?: string[];
    [key: string]: any;
}
/**
 * @public
 * @category Error
 *
 * @privateRemarks
 * CSFLE has a dependency on this error, it uses the constructor with a string argument
 */
export declare class MongoError extends Error {
    /** @internal */
    [kErrorLabels]: Set<string>;
    code?: number | string;
    topologyVersion?: TopologyVersion;
    constructor(message: string | Error);
    get name(): string;
    /** Legacy name for server error responses */
    get errmsg(): string;
    /**
     * Checks the error to see if it has an error label
     *
     * @param label - The error label to check for
     * @returns returns true if the error has the provided error label
     */
    hasErrorLabel(label: string): boolean;
    addErrorLabel(label: string): void;
    get errorLabels(): string[];
}
/**
 * An error coming from the mongo server
 *
 * @public
 * @category Error
 */
export declare class MongoServerError extends MongoError {
    code?: number;
    codeName?: string;
    writeConcernError?: Document;
    constructor(message: Error | ErrorDescription);
    get name(): string;
}
/**
 * An error generated by the driver
 *
 * @public
 * @category Error
 */
export declare class MongoDriverError extends MongoError {
    code?: string;
    constructor(message: string);
    get name(): string;
}
/**
 * An error generated when the driver encounters unexpected input
 * or reaches an unexpected/invalid internal state
 *
 * @privateRemarks
 * Should **never** be directly instantiated.
 *
 * @public
 * @category Error
 */
export declare class MongoRuntimeError extends MongoDriverError {
    protected constructor(message: string);
    get name(): string;
}
/** @internal */
declare const kBeforeHandshake: unique symbol;
export declare function isNetworkErrorBeforeHandshake(err: MongoNetworkError): boolean;
/**
 * An error indicating an issue with the network, including TCP errors and timeouts.
 * @public
 * @category Error
 */
export declare class MongoNetworkError extends MongoError {
    /** @internal */
    [kBeforeHandshake]?: boolean;
    constructor(message: string | Error, options?: {
        beforeHandshake?: boolean;
    });
    get name(): string;
}
/** @public */
export interface MongoNetworkTimeoutErrorOptions {
    /** Indicates the timeout happened before a connection handshake completed */
    beforeHandshake: boolean;
}
/**
 * An error indicating a network timeout occurred
 * @public
 * @category Error
 *
 * @privateRemarks
 * CSFLE has a dependency on this error with an instanceof check
 */
export declare class MongoNetworkTimeoutError extends MongoNetworkError {
    constructor(message: string, options?: MongoNetworkTimeoutErrorOptions);
    get name(): string;
}
/**
 * An error used when attempting to parse a value (like a connection string)
 * @public
 * @category Error
 */
export declare class MongoParseError extends MongoDriverError {
    constructor(message: string);
    get name(): string;
}
/**
 * An error signifying a general system issue
 * @public
 * @category Error
 */
export declare class MongoSystemError extends MongoError {
    /** An optional reason context, such as an error saved during flow of monitoring and selecting servers */
    reason?: TopologyDescription;
    constructor(message: string, reason: TopologyDescription);
    get name(): string;
}
/**
 * An error signifying a client-side server selection error
 * @public
 * @category Error
 */
export declare class MongoServerSelectionError extends MongoSystemError {
    constructor(message: string, reason: TopologyDescription);
    get name(): string;
}
/**
 * An error thrown when the server reports a writeConcernError
 * @public
 * @category Error
 */
export declare class MongoWriteConcernError extends MongoServerError {
    /** The result document (provided if ok: 1) */
    result?: Document;
    constructor(message: ErrorDescription, result: Document);
    get name(): string;
}
export declare function isRetryableWriteError(error: MongoError): boolean;
/** Determines whether an error is something the driver should attempt to retry */
export declare function isRetryableError(error: MongoError): boolean;
export declare function isNodeShuttingDownError(err: MongoError): boolean;
/**
 * Determines whether SDAM can recover from a given error. If it cannot
 * then the pool will be cleared, and server state will completely reset
 * locally.
 *
 * @see https://github.com/mongodb/specifications/blob/master/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#not-master-and-node-is-recovering
 */
export declare function isSDAMUnrecoverableError(error: MongoError): boolean;
export declare function isNetworkTimeoutError(err: MongoError): err is MongoNetworkError;
export declare function isResumableError(error?: MongoError, wireVersion?: number): boolean;
export {};
//# sourceMappingURL=error.d.ts.map